// This file is @generated by prost-build.
/// Endpoint represents a single logical "backend" implementing a service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endpoint {
    /// addresses of this endpoint. For EndpointSlices of addressType "IPv4" or "IPv6",
    /// the values are IP addresses in canonical form. The syntax and semantics of
    /// other addressType values are not defined. This must contain at least one
    /// address but no more than 100. EndpointSlices generated by the EndpointSlice
    /// controller will always have exactly 1 address. No semantics are defined for
    /// additional addresses beyond the first, and kube-proxy does not look at them.
    /// +listType=set
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// conditions contains information about the current status of the endpoint.
    #[prost(message, optional, tag = "2")]
    pub conditions: ::core::option::Option<EndpointConditions>,
    /// hostname of this endpoint. This field may be used by consumers of
    /// endpoints to distinguish endpoints from each other (e.g. in DNS names).
    /// Multiple endpoints which use the same hostname should be considered
    /// fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS
    /// Label (RFC 1123) validation.
    /// +optional
    #[prost(string, optional, tag = "3")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    /// targetRef is a reference to a Kubernetes object that represents this
    /// endpoint.
    /// +optional
    #[prost(message, optional, tag = "4")]
    pub target_ref: ::core::option::Option<super::super::core::v1::ObjectReference>,
    /// deprecatedTopology contains topology information part of the v1beta1
    /// API. This field is deprecated, and will be removed when the v1beta1
    /// API is removed (no sooner than kubernetes v1.24).  While this field can
    /// hold values, it is not writable through the v1 API, and any attempts to
    /// write to it will be silently ignored. Topology information can be found
    /// in the zone and nodeName fields instead.
    /// +optional
    #[prost(btree_map = "string, string", tag = "5")]
    pub deprecated_topology:
        ::prost::alloc::collections::BTreeMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// nodeName represents the name of the Node hosting this endpoint. This can
    /// be used to determine endpoints local to a Node.
    /// +optional
    #[prost(string, optional, tag = "6")]
    pub node_name: ::core::option::Option<::prost::alloc::string::String>,
    /// zone is the name of the Zone this endpoint exists in.
    /// +optional
    #[prost(string, optional, tag = "7")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
    /// hints contains information associated with how an endpoint should be
    /// consumed.
    /// +optional
    #[prost(message, optional, tag = "8")]
    pub hints: ::core::option::Option<EndpointHints>,
}
/// EndpointConditions represents the current condition of an endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EndpointConditions {
    /// ready indicates that this endpoint is ready to receive traffic,
    /// according to whatever system is managing the endpoint. A nil value
    /// should be interpreted as "true". In general, an endpoint should be
    /// marked ready if it is serving and not terminating, though this can
    /// be overridden in some cases, such as when the associated Service has
    /// set the publishNotReadyAddresses flag.
    /// +optional
    #[prost(bool, optional, tag = "1")]
    pub ready: ::core::option::Option<bool>,
    /// serving indicates that this endpoint is able to receive traffic,
    /// according to whatever system is managing the endpoint. For endpoints
    /// backed by pods, the EndpointSlice controller will mark the endpoint
    /// as serving if the pod's Ready condition is True. A nil value should be
    /// interpreted as "true".
    /// +optional
    #[prost(bool, optional, tag = "2")]
    pub serving: ::core::option::Option<bool>,
    /// terminating indicates that this endpoint is terminating. A nil value
    /// should be interpreted as "false".
    /// +optional
    #[prost(bool, optional, tag = "3")]
    pub terminating: ::core::option::Option<bool>,
}
/// EndpointHints provides hints describing how an endpoint should be consumed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointHints {
    /// forZones indicates the zone(s) this endpoint should be consumed by when
    /// using topology aware routing. May contain a maximum of 8 entries.
    /// +listType=atomic
    #[prost(message, repeated, tag = "1")]
    pub for_zones: ::prost::alloc::vec::Vec<ForZone>,
    /// forNodes indicates the node(s) this endpoint should be consumed by when
    /// using topology aware routing. May contain a maximum of 8 entries.
    /// This is an Alpha feature and is only used when the PreferSameTrafficDistribution
    /// feature gate is enabled.
    /// +listType=atomic
    #[prost(message, repeated, tag = "2")]
    pub for_nodes: ::prost::alloc::vec::Vec<ForNode>,
}
/// EndpointPort represents a Port used by an EndpointSlice
/// +structType=atomic
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointPort {
    /// name represents the name of this port. All ports in an EndpointSlice must have a unique name.
    /// If the EndpointSlice is derived from a Kubernetes service, this corresponds to the Service.ports\[\].name.
    /// Name must either be an empty string or pass DNS_LABEL validation:
    /// * must be no more than 63 characters long.
    /// * must consist of lower case alphanumeric characters or '-'.
    /// * must start and end with an alphanumeric character.
    /// Default is empty string.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// protocol represents the IP protocol for this port.
    /// Must be UDP, TCP, or SCTP.
    /// Default is TCP.
    #[prost(string, optional, tag = "2")]
    pub protocol: ::core::option::Option<::prost::alloc::string::String>,
    /// port represents the port number of the endpoint.
    /// If the EndpointSlice is derived from a Kubernetes service, this must be set
    /// to the service's target port. EndpointSlices used for other purposes may have
    /// a nil port.
    #[prost(int32, optional, tag = "3")]
    pub port: ::core::option::Option<i32>,
    /// The application protocol for this port.
    /// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
    /// This field follows standard Kubernetes label syntax.
    /// Valid values are either:
    ///
    /// * Un-prefixed protocol names - reserved for IANA standard service names (as per
    /// RFC-6335 and <https://www.iana.org/assignments/service-names>).
    ///
    /// * Kubernetes-defined prefixed names:
    ///    * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in <https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior->
    ///    * 'kubernetes.io/ws'  - WebSocket over cleartext as described in <https://www.rfc-editor.org/rfc/rfc6455>
    ///    * 'kubernetes.io/wss' - WebSocket over TLS as described in <https://www.rfc-editor.org/rfc/rfc6455>
    ///
    /// * Other protocols should use implementation-defined prefixed names such as
    /// mycompany.com/my-custom-protocol.
    /// +optional
    #[prost(string, optional, tag = "4")]
    pub app_protocol: ::core::option::Option<::prost::alloc::string::String>,
}
/// EndpointSlice represents a set of service endpoints. Most EndpointSlices are created by
/// the EndpointSlice controller to represent the Pods selected by Service objects. For a
/// given service there may be multiple EndpointSlice objects which must be joined to
/// produce the full set of endpoints; you can find all of the slices for a given service
/// by listing EndpointSlices in the service's namespace whose `kubernetes.io/service-name`
/// label contains the service's name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointSlice {
    /// Standard object's metadata.
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    /// addressType specifies the type of address carried by this EndpointSlice.
    /// All addresses in this slice must be the same type. This field is
    /// immutable after creation. The following address types are currently
    /// supported:
    /// * IPv4: Represents an IPv4 Address.
    /// * IPv6: Represents an IPv6 Address.
    /// * FQDN: Represents a Fully Qualified Domain Name. (Deprecated)
    /// The EndpointSlice controller only generates, and kube-proxy only processes,
    /// slices of addressType "IPv4" and "IPv6". No semantics are defined for
    /// the "FQDN" type.
    #[prost(string, optional, tag = "4")]
    pub address_type: ::core::option::Option<::prost::alloc::string::String>,
    /// endpoints is a list of unique endpoints in this slice. Each slice may
    /// include a maximum of 1000 endpoints.
    /// +listType=atomic
    #[prost(message, repeated, tag = "2")]
    pub endpoints: ::prost::alloc::vec::Vec<Endpoint>,
    /// ports specifies the list of network ports exposed by each endpoint in
    /// this slice. Each port must have a unique name. Each slice may include a
    /// maximum of 100 ports.
    /// Services always have at least 1 port, so EndpointSlices generated by the
    /// EndpointSlice controller will likewise always have at least 1 port.
    /// EndpointSlices used for other purposes may have an empty ports list.
    /// +optional
    /// +listType=atomic
    #[prost(message, repeated, tag = "3")]
    pub ports: ::prost::alloc::vec::Vec<EndpointPort>,
}
/// EndpointSliceList represents a list of endpoint slices
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointSliceList {
    /// Standard list metadata.
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ListMeta>,
    /// items is the list of endpoint slices
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<EndpointSlice>,
}
/// ForNode provides information about which nodes should consume this endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForNode {
    /// name represents the name of the node.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// ForZone provides information about which zones should consume this endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForZone {
    /// name represents the name of the zone.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}

impl crate::Resource for EndpointSlice {
    const API_VERSION: &'static str = "discovery.k8s.io/v1";
    const GROUP: &'static str = "discovery.k8s.io";
    const VERSION: &'static str = "v1";
    const KIND: &'static str = "EndpointSlice";
    const URL_PATH_SEGMENT: &'static str = "endpointslices";
    type Scope = crate::NamespaceResourceScope;
}
impl crate::Metadata for EndpointSlice {
    type Ty = crate::apimachinery::pkg::apis::meta::v1::ObjectMeta;
    fn metadata(&self) -> Option<&<Self as crate::Metadata>::Ty> {
        self.metadata.as_ref()
    }
    fn metadata_mut(&mut self) -> Option<&mut <Self as crate::Metadata>::Ty> {
        self.metadata.as_mut()
    }
}
