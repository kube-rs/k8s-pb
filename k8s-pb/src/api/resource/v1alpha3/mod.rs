// This file is @generated by prost-build.
/// CELDeviceSelector contains a CEL expression for selecting a device.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CelDeviceSelector {
    /// Expression is a CEL expression which evaluates a single device. It
    /// must evaluate to true when the device under consideration satisfies
    /// the desired criteria, and false when it does not. Any other result
    /// is an error and causes allocation of devices to abort.
    ///
    /// The expression's input is an object named "device", which carries
    /// the following properties:
    ///   - driver (string): the name of the driver which defines this device.
    ///   - attributes (map\[string\]object): the device's attributes, grouped by prefix
    ///     (e.g. device.attributes\["dra.example.com"\] evaluates to an object with all
    ///     of the attributes which were prefixed by "dra.example.com".
    ///   - capacity (map\[string\]object): the device's capacities, grouped by prefix.
    ///
    /// Example: Consider a device with driver="dra.example.com", which exposes
    /// two attributes named "model" and "ext.example.com/family" and which
    /// exposes one capacity named "modules". This input to this expression
    /// would have the following fields:
    ///
    ///      device.driver
    ///      device.attributes\["dra.example.com"\].model
    ///      device.attributes\["ext.example.com"\].family
    ///      device.capacity\["dra.example.com"\].modules
    ///
    /// The device.driver field can be used to check for a specific driver,
    /// either as a high-level precondition (i.e. you only want to consider
    /// devices from this driver) or as part of a multi-clause expression
    /// that is meant to consider devices from different drivers.
    ///
    /// The value type of each attribute is defined by the device
    /// definition, and users who write these expressions must consult the
    /// documentation for their specific drivers. The value type of each
    /// capacity is Quantity.
    ///
    /// If an unknown prefix is used as a lookup in either device.attributes
    /// or device.capacity, an empty map will be returned. Any reference to
    /// an unknown field will cause an evaluation error and allocation to
    /// abort.
    ///
    /// A robust expression should check for the existence of attributes
    /// before referencing them.
    ///
    /// For ease of use, the cel.bind() function is enabled, and can be used
    /// to simplify expressions that access multiple attributes with the
    /// same domain. For example:
    ///
    ///      cel.bind(dra, device.attributes\["dra.example.com"\], dra.someBool && dra.anotherBool)
    ///
    /// The length of the expression must be smaller or equal to 10 Ki. The
    /// cost of evaluating it is also limited based on the estimated number
    /// of logical steps.
    ///
    /// +required
    #[prost(string, optional, tag = "1")]
    pub expression: ::core::option::Option<::prost::alloc::string::String>,
}
/// DeviceSelector must have exactly one field set.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceSelector {
    /// CEL contains a CEL expression for selecting a device.
    ///
    /// +optional
    /// +oneOf=SelectorType
    #[prost(message, optional, tag = "1")]
    pub cel: ::core::option::Option<CelDeviceSelector>,
}
/// The device this taint is attached to has the "effect" on
/// any claim which does not tolerate the taint and, through the claim,
/// to pods using the claim.
///
/// +protobuf.options.(gogoproto.goproto_stringer)=false
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceTaint {
    /// The taint key to be applied to a device.
    /// Must be a label name.
    ///
    /// +required
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    /// The taint value corresponding to the taint key.
    /// Must be a label value.
    ///
    /// +optional
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    /// The effect of the taint on claims that do not tolerate the taint
    /// and through such claims on the pods using them.
    /// Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for
    /// nodes is not valid here.
    ///
    /// +required
    #[prost(string, optional, tag = "3")]
    pub effect: ::core::option::Option<::prost::alloc::string::String>,
    /// TimeAdded represents the time at which the taint was added.
    /// Added automatically during create or update if not set.
    ///
    /// +optional
    #[prost(message, optional, tag = "4")]
    pub time_added: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::Time>,
}
/// DeviceTaintRule adds one taint to all devices which match the selector.
/// This has the same effect as if the taint was specified directly
/// in the ResourceSlice by the DRA driver.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceTaintRule {
    /// Standard object metadata
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    /// Spec specifies the selector and one taint.
    ///
    /// Changing the spec automatically increments the metadata.generation number.
    #[prost(message, optional, tag = "2")]
    pub spec: ::core::option::Option<DeviceTaintRuleSpec>,
}
/// DeviceTaintRuleList is a collection of DeviceTaintRules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceTaintRuleList {
    /// Standard list metadata
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ListMeta>,
    /// Items is the list of DeviceTaintRules.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<DeviceTaintRule>,
}
/// DeviceTaintRuleSpec specifies the selector and one taint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceTaintRuleSpec {
    /// DeviceSelector defines which device(s) the taint is applied to.
    /// All selector criteria must be satified for a device to
    /// match. The empty selector matches all devices. Without
    /// a selector, no devices are matches.
    ///
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub device_selector: ::core::option::Option<DeviceTaintSelector>,
    /// The taint that gets applied to matching devices.
    ///
    /// +required
    #[prost(message, optional, tag = "2")]
    pub taint: ::core::option::Option<DeviceTaint>,
}
/// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to.
/// The empty selector matches all devices. Without a selector, no devices
/// are matched.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceTaintSelector {
    /// If DeviceClassName is set, the selectors defined there must be
    /// satisfied by a device to be selected. This field corresponds
    /// to class.metadata.name.
    ///
    /// +optional
    #[prost(string, optional, tag = "1")]
    pub device_class_name: ::core::option::Option<::prost::alloc::string::String>,
    /// If driver is set, only devices from that driver are selected.
    /// This fields corresponds to slice.spec.driver.
    ///
    /// +optional
    #[prost(string, optional, tag = "2")]
    pub driver: ::core::option::Option<::prost::alloc::string::String>,
    /// If pool is set, only devices in that pool are selected.
    ///
    /// Also setting the driver name may be useful to avoid
    /// ambiguity when different drivers use the same pool name,
    /// but this is not required because selecting pools from
    /// different drivers may also be useful, for example when
    /// drivers with node-local devices use the node name as
    /// their pool name.
    ///
    /// +optional
    #[prost(string, optional, tag = "3")]
    pub pool: ::core::option::Option<::prost::alloc::string::String>,
    /// If device is set, only devices with that name are selected.
    /// This field corresponds to slice.spec.devices\[\].name.
    ///
    /// Setting also driver and pool may be required to avoid ambiguity,
    /// but is not required.
    ///
    /// +optional
    #[prost(string, optional, tag = "4")]
    pub device: ::core::option::Option<::prost::alloc::string::String>,
    /// Selectors contains the same selection criteria as a ResourceClaim.
    /// Currently, CEL expressions are supported. All of these selectors
    /// must be satisfied.
    ///
    /// +optional
    /// +listType=atomic
    #[prost(message, repeated, tag = "5")]
    pub selectors: ::prost::alloc::vec::Vec<DeviceSelector>,
}

impl crate::Resource for DeviceTaintRule {
    const API_VERSION: &'static str = "resource.k8s.io/v1alpha3";
    const GROUP: &'static str = "resource.k8s.io";
    const VERSION: &'static str = "v1alpha3";
    const KIND: &'static str = "DeviceTaintRule";
    const URL_PATH_SEGMENT: &'static str = "devicetaintrules";
    type Scope = crate::ClusterResourceScope;
}
impl crate::Metadata for DeviceTaintRule {
    type Ty = crate::apimachinery::pkg::apis::meta::v1::ObjectMeta;
    fn metadata(&self) -> Option<&<Self as crate::Metadata>::Ty> {
        self.metadata.as_ref()
    }
    fn metadata_mut(&mut self) -> Option<&mut <Self as crate::Metadata>::Ty> {
        self.metadata.as_mut()
    }
}
impl crate::HasSpec for DeviceTaintRule {
    type Spec = crate::api::resource::v1alpha3::DeviceTaintRuleSpec;
    fn spec(&self) -> Option<&<Self as crate::HasSpec>::Spec> {
        self.spec.as_ref()
    }
    fn spec_mut(&mut self) -> Option<&mut <Self as crate::HasSpec>::Spec> {
        self.spec.as_mut()
    }
}
