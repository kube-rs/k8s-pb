// This file is @generated by prost-build.
/// BasicSchedulingPolicy indicates that standard Kubernetes
/// scheduling behavior should be used.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BasicSchedulingPolicy {}
/// GangSchedulingPolicy defines the parameters for gang scheduling.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GangSchedulingPolicy {
    /// MinCount is the minimum number of pods that must be schedulable or scheduled
    /// at the same time for the scheduler to admit the entire group.
    /// It must be a positive integer.
    ///
    /// +required
    #[prost(int32, optional, tag = "1")]
    pub min_count: ::core::option::Option<i32>,
}
/// PodGroup represents a set of pods with a common scheduling policy.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PodGroup {
    /// Name is a unique identifier for the PodGroup within the Workload.
    /// It must be a DNS label. This field is immutable.
    ///
    /// +required
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Policy defines the scheduling policy for this PodGroup.
    ///
    /// +required
    #[prost(message, optional, tag = "3")]
    pub policy: ::core::option::Option<PodGroupPolicy>,
}
/// PodGroupPolicy defines the scheduling configuration for a PodGroup.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PodGroupPolicy {
    /// Basic specifies that the pods in this group should be scheduled using
    /// standard Kubernetes scheduling behavior.
    ///
    /// +optional
    /// +oneOf=PolicySelection
    #[prost(message, optional, tag = "2")]
    pub basic: ::core::option::Option<BasicSchedulingPolicy>,
    /// Gang specifies that the pods in this group should be scheduled using
    /// all-or-nothing semantics.
    ///
    /// +optional
    /// +oneOf=PolicySelection
    #[prost(message, optional, tag = "3")]
    pub gang: ::core::option::Option<GangSchedulingPolicy>,
}
/// DEPRECATED - This group version of PriorityClass is deprecated by scheduling.k8s.io/v1/PriorityClass.
/// PriorityClass defines mapping from a priority class name to the priority
/// integer value. The value can be any valid integer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriorityClass {
    /// Standard object's metadata.
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    /// value represents the integer value of this priority class. This is the actual priority that pods
    /// receive when they have the name of this class in their pod spec.
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
    /// globalDefault specifies whether this PriorityClass should be considered as
    /// the default priority for pods that do not have any priority class.
    /// Only one PriorityClass can be marked as `globalDefault`. However, if more than
    /// one PriorityClasses exists with their `globalDefault` field set to true,
    /// the smallest value of such global default PriorityClasses will be used as the default priority.
    /// +optional
    #[prost(bool, optional, tag = "3")]
    pub global_default: ::core::option::Option<bool>,
    /// description is an arbitrary string that usually provides guidelines on
    /// when this priority class should be used.
    /// +optional
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// preemptionPolicy is the Policy for preempting pods with lower priority.
    /// One of Never, PreemptLowerPriority.
    /// Defaults to PreemptLowerPriority if unset.
    /// +optional
    #[prost(string, optional, tag = "5")]
    pub preemption_policy: ::core::option::Option<::prost::alloc::string::String>,
}
/// PriorityClassList is a collection of priority classes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PriorityClassList {
    /// Standard list metadata
    /// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ListMeta>,
    /// items is the list of PriorityClasses
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<PriorityClass>,
}
/// TypedLocalObjectReference allows to reference typed object inside the same namespace.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TypedLocalObjectReference {
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is empty, the specified Kind must be in the core API group.
    /// For any other third-party types, setting APIGroup is required.
    /// It must be a DNS subdomain.
    ///
    /// +optional
    #[prost(string, optional, tag = "1")]
    pub api_group: ::core::option::Option<::prost::alloc::string::String>,
    /// Kind is the type of resource being referenced.
    /// It must be a path segment name.
    ///
    /// +required
    #[prost(string, optional, tag = "2")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    /// Name is the name of resource being referenced.
    /// It must be a path segment name.
    ///
    /// +required
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Workload allows for expressing scheduling constraints that should be used
/// when managing lifecycle of workloads from scheduling perspective,
/// including scheduling, preemption, eviction and other phases.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workload {
    /// Standard object's metadata.
    /// Name must be a DNS subdomain.
    ///
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ObjectMeta>,
    /// Spec defines the desired behavior of a Workload.
    ///
    /// +required
    #[prost(message, optional, tag = "2")]
    pub spec: ::core::option::Option<WorkloadSpec>,
}
/// WorkloadList contains a list of Workload resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadList {
    /// Standard list metadata.
    ///
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<super::super::super::apimachinery::pkg::apis::meta::v1::ListMeta>,
    /// Items is the list of Workloads.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Workload>,
}
/// WorkloadSpec defines the desired state of a Workload.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadSpec {
    /// ControllerRef is an optional reference to the controlling object, such as a
    /// Deployment or Job. This field is intended for use by tools like CLIs
    /// to provide a link back to the original workload definition.
    /// When set, it cannot be changed.
    ///
    /// +optional
    #[prost(message, optional, tag = "1")]
    pub controller_ref: ::core::option::Option<TypedLocalObjectReference>,
    /// PodGroups is the list of pod groups that make up the Workload.
    /// The maximum number of pod groups is 8. This field is immutable.
    ///
    /// +required
    /// +listType=map
    /// +listMapKey=name
    #[prost(message, repeated, tag = "2")]
    pub pod_groups: ::prost::alloc::vec::Vec<PodGroup>,
}

impl crate::Resource for Workload {
    const API_VERSION: &'static str = "scheduling.k8s.io/v1alpha1";
    const GROUP: &'static str = "scheduling.k8s.io";
    const VERSION: &'static str = "v1alpha1";
    const KIND: &'static str = "Workload";
    const URL_PATH_SEGMENT: &'static str = "workloads";
    type Scope = crate::NamespaceResourceScope;
}
impl crate::Metadata for Workload {
    type Ty = crate::apimachinery::pkg::apis::meta::v1::ObjectMeta;
    fn metadata(&self) -> Option<&<Self as crate::Metadata>::Ty> {
        self.metadata.as_ref()
    }
    fn metadata_mut(&mut self) -> Option<&mut <Self as crate::Metadata>::Ty> {
        self.metadata.as_mut()
    }
}
impl crate::HasSpec for Workload {
    type Spec = crate::api::scheduling::v1alpha1::WorkloadSpec;
    fn spec(&self) -> Option<&<Self as crate::HasSpec>::Spec> {
        self.spec.as_ref()
    }
    fn spec_mut(&mut self) -> Option<&mut <Self as crate::HasSpec>::Spec> {
        self.spec.as_mut()
    }
}
